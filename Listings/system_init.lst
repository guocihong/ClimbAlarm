C51 COMPILER V9.54   SYSTEM_INIT                                                           07/01/2016 17:14:37 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SYSTEM_INIT
OBJECT MODULE PLACED IN .\Objects\system_init.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE system_init.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\syste
                    -m_init.lst) OBJECT(.\Objects\system_init.obj)

line level    source

   1          #include "system_init.h"
   2          
   3          static void gpio_init(void);
   4          static void get_defence_info(void);
   5          static void get_config_info(void);
   6          
   7          /* AD sample */
   8          extern bdata  bit      ad_sensor_mask;              //传感器掩码
   9          extern xdata  Uint16   ad_still_dn;                 //静态拉力值下限
  10          extern xdata  Uint16   ad_still_up;                 //静态拉力值上限
  11          extern xdata  Byte     ad_still_Dup;                //报警阀值上限
  12          
  13          /* variables for beep */
  14          extern xdata  Uint16   beep_during_temp;            //预设的一次蜂鸣持续时间, 单位:tick
  15          
  16          /* 传感器采样偏差 */
  17          extern xdata  Uint16   sensor_sample_offset;        //传感器采样偏差：没有外力时，传感器采样值不为0，大约4
             -00左右，需要矫正。瞬间张力 = 采样值 - 采样偏差
  18          
  19          /* for system */
  20          extern idata  Byte     gl_comm_addr;                //本模块485通信地址
  21          extern bdata  bit      system_2or1;                 //双/单防区标志: 0 - 双; 1 - 单
  22          
  23          void system_init(void)
  24          {
  25   1              gpio_init();
  26   1      
  27   1              get_config_info();
  28   1      
  29   1              status_task_init();
  30   1              adc_task_init();
  31   1              uart_task_init();
  32   1              doorkeep_task_init();
  33   1              alarm_task_init();
  34   1      
  35   1              timer0_init();
  36   1      }
  37          
  38          
  39          static void gpio_init(void)
  40          {
  41   1              Uint32 i;
  42   1              Byte j;
  43   1      
  44   1              //设置P10为AD模式
  45   1              P1M1 = 0x01;
  46   1              P1M0 = 0x00;
  47   1      
  48   1              //设置P31为高阻输入,用来检测是否插入跳线帽，主要用来屏蔽报警
  49   1              P3M1 = 0x02;
  50   1              P3M0 = 0x00;
  51   1      
  52   1              ad_sensor_mask = 1;//缺省:报警不屏蔽
  53   1              do
C51 COMPILER V9.54   SYSTEM_INIT                                                           07/01/2016 17:14:37 PAGE 2   

  54   1              {
  55   2                      j = 255;
  56   2                      while (j > 0)  j--;
  57   2                      if (ad_sensor_mask == !P31)
  58   2                      {
  59   3                              i++;
  60   3                      }
  61   2                      else
  62   2                      {
  63   3                              i = 0;
  64   3                              ad_sensor_mask = !P31;
  65   3                      }
  66   2              } while (i < 8);
  67   1              ad_sensor_mask = !ad_sensor_mask;
  68   1      
  69   1              //设置P31,P32,P33,P34为强推挽输出
  70   1              P3M1 = 0x00;
  71   1              P3M0 = 0x1E;
  72   1              P32 = 1;//防拆不报警
  73   1              P33 = 1;//杆自身不报警
  74   1              P34 = 1;//开关量上电闭合
  75   1      
  76   1              //设置P46为高阻输入
  77   1              P4M1 = 0x40;
  78   1              P4M0 = 0x00;
  79   1              P4SW = 0x70;
  80   1      
  81   1              //闪一下2个LED -- 全部点亮，用于检测所有LED是否完好
  82   1              P32 = 0;   //点亮2个LED
  83   1              P33 = 0;
  84   1      
  85   1              gl_comm_addr= 55;
  86   1              system_2or1 = 1;
  87   1      
  88   1              i = 150000;
  89   1              while (i>0)  i--;
  90   1      
  91   1              P32 = 1;   //熄灭2个LED
  92   1              P33 = 1;
  93   1      
  94   1              //延时
  95   1              i = 150000;
  96   1              while (i>0)  i--;
  97   1      }
  98          
  99          //读取系统预设数据
 100          static void get_config_info(void)
 101          {
 102   1              Byte temp;
 103   1      
 104   1              //使能Flash访问
 105   1              flash_enable();
 106   1      
 107   1              //读静态张力值范围
 108   1              temp = flash_read(EEPROM_SECTOR3);
 109   1              if (temp == 0x5A) { //有有效设置
 110   2                      //下限
 111   2                      temp = flash_read(EEPROM_SECTOR3 + 1);
 112   2                      ad_still_dn = (Uint16)temp << 8;
 113   2                      temp = flash_read(EEPROM_SECTOR3 + 2);
 114   2                      ad_still_dn += temp;
 115   2                      //上限
C51 COMPILER V9.54   SYSTEM_INIT                                                           07/01/2016 17:14:37 PAGE 3   

 116   2                      temp = flash_read(EEPROM_SECTOR3 + 3);
 117   2                      ad_still_up = (Uint16)temp << 8;
 118   2                      temp = flash_read(EEPROM_SECTOR3 + 4);
 119   2                      ad_still_up += temp;
 120   2                      //有效否?
 121   2                      if ((ad_still_dn < STD_STILL_DN) ||
 122   2                              (ad_still_up > STD_STILL_UP) ||
 123   2                              (ad_still_dn >= ad_still_up)) { //无合法数据，取缺省值
 124   3                              ad_still_dn = STD_STILL_DN;
 125   3                              ad_still_up = STD_STILL_UP;
 126   3                      }
 127   2              } else {        //无有效设置，取缺省值
 128   2                      ad_still_dn = STD_STILL_DN;
 129   2                      ad_still_up = STD_STILL_UP;
 130   2              }
 131   1      
 132   1              //读报警阀值参数
 133   1              temp = flash_read(EEPROM_SECTOR4);
 134   1              if (temp == 0x5A) { //有有效设置
 135   2                      ad_still_Dup = flash_read(EEPROM_SECTOR4 + 1);
 136   2      
 137   2                      //是否有效？
 138   2                      if ((ad_still_Dup < STD_ALARM_MIN) || (ad_still_Dup > STD_ALARM_MAX))
 139   2                              ad_still_Dup = STD_ALARM_DEF;    //无合法数据，取缺省值
 140   2              } else {        //无有效设置，取缺省值
 141   2                      ad_still_Dup = STD_ALARM_DEF;
 142   2              }
 143   1      
 144   1              //6. 读声光报警时间设置
 145   1              temp = flash_read(EEPROM_SECTOR5);
 146   1              if (temp == 0x5A) { //有有效设置
 147   2                      temp = flash_read(EEPROM_SECTOR5 + 1);
 148   2                      beep_during_temp = (Uint16)(((Uint32)temp * 1000) / SCHEDULER_TICK);
 149   2              } else {        //取缺省值
 150   2                      beep_during_temp = 0;   //单位： tick
 151   2              }
 152   1      
 153   1              //读传感器采样偏差
 154   1              temp = flash_read(EEPROM_SECTOR6);
 155   1              if (temp == 0x5A) { //有有效设置
 156   2                      temp = flash_read(EEPROM_SECTOR6 + 1);
 157   2                      sensor_sample_offset = ((Uint16)temp << 8);
 158   2                      temp = flash_read(EEPROM_SECTOR6 + 2);
 159   2                      sensor_sample_offset += temp;
 160   2              } else {        //无有效设置
 161   2                      sensor_sample_offset = 0;
 162   2              }
 163   1      
 164   1              //9. 禁止Flash访问
 165   1              flash_disable();
 166   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    578    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.54   SYSTEM_INIT                                                           07/01/2016 17:14:37 PAGE 4   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
