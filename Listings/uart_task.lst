C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART_TASK
OBJECT MODULE PLACED IN .\Objects\uart_task.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE task\uart\uart_task.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listin
                    -gs\uart_task.lst) OBJECT(.\Objects\uart_task.obj)

line level    source

   1          #include "task/uart/uart_task.h"
   2          
   3          #define REPLY_DLY   (10/SCHEDULER_TICK)             //ÊÕµ½PCÃüÁîºóµÄÓ¦´ğÑÓÊ±
   4          
   5          /* ÏµÍ³¼ÆÊ± */
   6          extern xdata  Byte     gl_ack_tick;                     //Ó¦´ğÑÓÊ±¼ÆÊ± tick
   7          
   8          /* UART1 */
   9          extern xdata  Byte     msg1_buf[MAX_RecvFrame];     // received message, used for proceding
  10          extern bdata  bit      msg1_buf_valid;              // received valid flag
  11          extern xdata  Byte     recv1_buf[MAX_RecvFrame];    // receiving buffer
  12          extern idata  Byte     recv1_state;                 // receive state
  13          extern idata  Byte     recv1_timer;                 // receive time-out, ÓÃÓÚ×Ö½Ú¼ä³¬Ê±ÅĞ¶¨
  14          extern idata  Byte     recv1_chksum;                // computed checksum
  15          extern idata  Byte     recv1_ctr;                   // reveiving pointer
  16          
  17          extern xdata  Byte     trans1_buf[MAX_TransFrame];  // uart transfer message buffer
  18          extern idata  Byte     trans1_ctr;                  // transfer pointer
  19          extern idata  Byte     trans1_size;                 // transfer bytes number
  20          extern idata  Byte     trans1_chksum;               // computed check-sum of already transfered message
  21          extern bdata  bit      trans1_occupy;               // ·¢ËÍÆ÷±»Õ¼ÓÃ±êÖ¾£¬1-±»Õ¼ÓÃ, 0-¿ÕÏĞ
  22          
  23          extern  data  Byte     uart1_q_index;               // ÕıÔÚ·¢ËÍÄ³¶ÓÁĞÏîµÄĞòºÅ£ºÈôÎª0xFF, ±íÊ¾Ã»ÓĞÈÎºÎÏî½øÈ
             -ë·¢ËÍÁ÷³Ì
  24          extern xdata  sUART_Q  uart1_q[UART_QUEUE_NUM];     // ´®¿Ú¶ÓÁĞ
  25          
  26          /* for system */
  27          extern idata  Byte     system_status;               //ÏµÍ³×´Ì¬
  28          extern bdata  bit      system_2or1;                 //Ë«/µ¥·ÀÇø±êÖ¾: 0 - Ë«; 1 - µ¥
  29          extern idata  Byte     gl_comm_addr;                //±¾Ä£¿é485Í¨ĞÅµØÖ·
  30          
  31          /* variables for alarm output */
  32          extern bdata  bit      ad_alarm_flag;               //ÍâÁ¦±¨¾¯±êÖ¾
  33          
  34          /* variables for beep */
  35          extern xdata  Uint16   beep_during_temp;            //Ô¤ÉèµÄÒ»´Î·äÃù³ÖĞøÊ±¼ä, µ¥Î»:tick 
  36          
  37          /* Doorkeep(ÃÅ´Å) */
  38          extern bdata  bit      gl_dk_status;                //ÃÅ´Å¿ª¹Ø×´Ì¬£¨Ã¿1s¶¯Ì¬¼ì²â£©: 1 - ±ÕºÏ; 0 - ´ò¿ª(ĞèÒ
             -ª±¨¾¯)
  39          
  40          /* AD sample */
  41          extern xdata  Union16  ad_chn_sample;               //×îĞÂÒ»ÂÖ²ÉÑùÖµ£¨ÒÑ¾ùºâÈ¥ÔëÉù£¬Ã¿Í¨µÀÒ»¸öµã£¬Ñ­»·±£´æ
             -£©
  42          extern xdata  sAD_BASE ad_chn_base;                 //¸÷Í¨µÀÔËĞĞÊ±¾²Ì¬»ù×¼Öµ/ÉÏÏÂÏŞ·§Öµ£¨µ¥Î»£º²ÉÑùÖµ£©
  43          extern xdata  Uint16   ad_still_dn;                 //¾²Ì¬À­Á¦ÖµÏÂÏŞ
  44          extern xdata  Uint16   ad_still_up;                 //¾²Ì¬À­Á¦ÖµÉÏÏŞ
  45          extern xdata  Byte     ad_still_Dup;                //±¨¾¯·§ÖµÉÏÏŞ
  46          
  47          /* ´«¸ĞÆ÷²ÉÑùÆ«²î */
  48          extern xdata  Uint16   sensor_sample_offset;        //´«¸ĞÆ÷²ÉÑùÆ«²î£ºÃ»ÓĞÍâÁ¦Ê±£¬´«¸ĞÆ÷²ÉÑùÖµ²»Îª0£¬´óÔ¼4
             -00×óÓÒ£¬ĞèÒª½ÃÕı¡£Ë²¼äÕÅÁ¦ = ²ÉÑùÖµ - ²ÉÑùÆ«²î
  49                                                              
  50          
C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 2   

  51          Byte check_still_stress(Byte index);
  52          
  53          void uart_task_init(void)
  54          {
  55   1              Byte i;
  56   1      
  57   1              //uart1Ïà¹Ø±äÁ¿³õÊ¼»¯
  58   1              msg1_buf_valid = FALSE;
  59   1              recv1_state = FSA_INIT;
  60   1              recv1_timer = 0;
  61   1              recv1_ctr = 0;
  62   1              recv1_chksum = 0;
  63   1              trans1_size = 0;
  64   1              trans1_ctr = 0;
  65   1              trans1_occupy = 0;       //¿ÕÏĞ
  66   1      
  67   1              for (i = 0; i < UART_QUEUE_NUM; i++){
  68   2                      uart1_q[i].flag = 0; //¾ù¿ÕÏĞ
  69   2              }
  70   1              uart1_q_index = 0xFF;    //ÎŞ¶ÓÁĞÏî½øÈë·¢ËÍÁ÷³Ì
  71   1      
  72   1              //UARTÓ²¼ş³õÊ¼»¯
  73   1              uart_init();             //Ö®ºó£¬ÒÑ¾­×¼±¸ºÃ´®¿ÚÊÕ·¢£¬Ö»ÊÇ»¹Î´Ê¹ÄÜÈ«¾ÖÖĞ¶Ï
  74   1      }
  75          
  76          void uart_task(void)
  77          {
  78   1              Byte   i, j;
  79   1              Uint16 temp16;
  80   1      
  81   1              //1.½ÓÊÕ²¢´¦Àí UART1£ºÀ´×ÔÉÏÎ»»úµÄÃüÁî°ü
  82   1              if (msg1_buf_valid) {
  83   2                      //a.1 ÊÇ·ñĞèÒªÖ´ĞĞ±¾ÃüÁî
  84   2                      if (msg1_buf[0] == CMD_ADDR_BC) {
  85   3                              //¹ã²¥µØÖ·»òÖ¸¶¨±¾Éè±¸, ĞèÒªÖ´ĞĞ
  86   3                              switch (msg1_buf[3])
  87   3                              {
  88   4                              case CMD_ZL_PRE://ÕÅÁ¦/Âö³å×¨ÓÃÃüÁî±êÖ¾
  89   4                                      switch (msg1_buf[5])
  90   4                                      {
  91   5                                      case 0x10: //¶ÁÅäÖÃ²ÎÊı
  92   5                                              //ÔÚUART¶ÓÁĞÖĞÕÒ¿ÕÏĞBuffer
  93   5                                              i = uart1_get_buffer();
  94   5                                              if (i < UART_QUEUE_NUM) {
  95   6                                                      //ÕÒµ½ÁË¿ÕÏĞbuffer, Ğ´Èëdata
  96   6                                                      uart1_q[i].tdata[0]  = FRAME_STX;
  97   6                                                      uart1_q[i].tdata[1]  = msg1_buf[1];                  //Ä¿µÄµØÖ·
  98   6                                                      uart1_q[i].tdata[2]  = gl_comm_addr;             //Ô´µØÖ·
  99   6                                                      uart1_q[i].tdata[3]  = 0x1E;                     //ÃüÁî³¤¶È
 100   6                                                      uart1_q[i].tdata[4]  = CMD_ZL_PRE;                       //ÃüÁîID
 101   6                                                      uart1_q[i].tdata[5]  = 0x1C;                     //²ÎÊı1
 102   6                                                      uart1_q[i].tdata[6]  = 0x08;                     //²ÎÊı2
 103   6                                                      uart1_q[i].tdata[7]  = 0x00;  //ÕÅÁ¦ÑÚÂë×ó
 104   6                                                      uart1_q[i].tdata[8]  = 0x00;   //ÕÅÁ¦ÑÚÂëÓÒ
 105   6                                                      uart1_q[i].tdata[9]  = HIGH(ad_still_dn);        //¾²Ì¬ÕÅÁ¦ÔÊĞíÏÂÏŞ¸ß
 106   6                                                      uart1_q[i].tdata[10] = LOW(ad_still_dn);         //¾²Ì¬ÕÅÁ¦ÔÊĞíÏÂÏŞµÍ
 107   6                                                      uart1_q[i].tdata[11] = HIGH(ad_still_up);        //¾²Ì¬ÕÅÁ¦ÔÊĞíÉÏÏŞ¸ß
 108   6                                                      uart1_q[i].tdata[12] = LOW(ad_still_up);         //¾²Ì¬ÕÅÁ¦ÔÊĞíÉÏÏŞµÍ
 109   6                                                      uart1_q[i].tdata[13] = 66;                       //±¨¾¯·§ÖµÏÂ¸¡±ÈÀı£¬¹Ì¶¨Îª66
 110   6                                                      for (j = 0; j < 7; j++) {                        //±¨¾¯·§ÖµÔÊĞíÉÏ¸¡×ó1~8
 111   7                                                              uart1_q[i].tdata[14 + j] = ad_still_Dup;
 112   7                                                      }
C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 3   

 113   6      
 114   6                                                      uart1_q[i].tdata[21] = 0;
 115   6                                                      for (j = 0; j < 7; j++) {                        //±¨¾¯·§ÖµÔÊĞíÉÏ¸¡ÓÒ1~8
 116   7                                                              uart1_q[i].tdata[22 + j] = ad_still_Dup;
 117   7                                                      }
 118   6                                                      uart1_q[i].tdata[29] = 0;
 119   6                                                      uart1_q[i].tdata[30] = system_2or1;              //Ë«/µ¥·ÀÇø
 120   6                                                      uart1_q[i].tdata[31] = gl_comm_addr;             //²¦ÂëµØÖ·
 121   6                                                      uart1_q[i].tdata[32] = (Byte)(((Uint32)beep_during_temp * SCHEDULER_TICK) / 1000);      //Éù¹â±¨¾¯Êä³öÊ±¼
             -ä
 122   6                                                      uart1_q[i].tdata[33] = 0;                        //Áª¶¯Êä³öÊ±¼ä
 123   6                                                      uart1_q[i].len = 35;
 124   6                                              } else {
 125   6                                                      //ÎŞ¿ÕÏĞbuffer, ¶ªÆú±¾ÃüÁî
 126   6                                                      //¼ì²é: ÈôÓĞ¶ÓÁĞÏîÕıÔÚ·¢ËÍ, µÈ´ıËüÍê³É
 127   6                                                      while (uart1_q_index != 0xFF);  //ÈôËÀËø,½«ÒıÆğ WDT ¸´Î»
 128   6                                              }
 129   5                                              break;
 130   5      
 131   5                                      case 0x12: //¶Á±¨¾¯ĞÅÏ¢
 132   5                                              //ÔÚUART¶ÓÁĞÖĞÕÒ¿ÕÏĞBuffer
 133   5                                              i = uart1_get_buffer();
 134   5                                              if (i < UART_QUEUE_NUM) {
 135   6                                                      //ÕÒµ½ÁË¿ÕÏĞbuffer, Ğ´Èëdata
 136   6                                                      uart1_q[i].tdata[0]  = FRAME_STX;
 137   6                                                      uart1_q[i].tdata[1]  = msg1_buf[1];                 //Ä¿µÄµØÖ·
 138   6                                                      uart1_q[i].tdata[2]  = gl_comm_addr;            //Ô´µØÖ·
 139   6                                                      uart1_q[i].tdata[3]  = 0x0A;                    //ÃüÁî³¤¶È
 140   6                                                      uart1_q[i].tdata[4]  = CMD_ZL_PRE;              //ÃüÁîID
 141   6                                                      uart1_q[i].tdata[5]  = 0x08;                    //²ÎÊı1
 142   6                                                      uart1_q[i].tdata[6]  = 0x1A;                    //²ÎÊı1
 143   6                                                      uart1_q[i].tdata[7]  = 0x00;                    //ÕÅÁ¦ÑÚÂë×ó
 144   6                                                      uart1_q[i].tdata[8]  = 0x00;                    //ÕÅÁ¦ÑÚÂëÓÒ
 145   6      
 146   6                                                      uart1_q[i].tdata[9]  = (Byte)ad_alarm_flag;     //ÍâÁ¦±¨¾¯×ó
 147   6                                                      uart1_q[i].tdata[10] = 0x00;                    //ÍâÁ¦±¨¾¯ÓÒ
 148   6      
 149   6                                                      uart1_q[i].tdata[11] = 0x00;                    //¾²Ì¬ÕÅÁ¦±¨¾¯×ó
 150   6                                                      uart1_q[i].tdata[12] = 0x00;                    //¾²Ì¬ÕÅÁ¦±¨¾¯ÓÒ
 151   6                                                      
 152   6                                                      uart1_q[i].tdata[13] = (Byte)(!gl_dk_status);   //ÃÅ´Å
 153   6                                                      uart1_q[i].len = 15;
 154   6                                              } else {
 155   6                                                      //ÎŞ¿ÕÏĞbuffer, ¶ªÆú±¾ÃüÁî
 156   6                                                      //¼ì²é: ÈôÓĞ¶ÓÁĞÏîÕıÔÚ·¢ËÍ, µÈ´ıËüÍê³É
 157   6                                                      while (uart1_q_index != 0xFF);  //ÈôËÀËø,½«ÒıÆğ WDT ¸´Î»
 158   6                                              }
 159   5                                              break;
 160   5      
 161   5                                      case 0x14: //¶ÁË²¼äÕÅÁ¦
 162   5                                              //ÔÚUART¶ÓÁĞÖĞÕÒ¿ÕÏĞBuffer
 163   5                                              i = uart1_get_buffer();
 164   5                                              if (i < UART_QUEUE_NUM) {
 165   6                                                      //ÕÒµ½ÁË¿ÕÏĞbuffer, Ğ´Èëdata
 166   6                                                      uart1_q[i].tdata[0] = FRAME_STX;
 167   6                                                      uart1_q[i].tdata[1] = msg1_buf[1];          //Ä¿µÄµØÖ·
 168   6                                                      uart1_q[i].tdata[2] = gl_comm_addr;         //Ô´µØÖ·
 169   6                                                      uart1_q[i].tdata[3] = 0x23;
 170   6                                                      uart1_q[i].tdata[4] = CMD_ZL_PRE;
 171   6                                                      uart1_q[i].tdata[5] = 0x21;
 172   6                                                      uart1_q[i].tdata[6] = 0x1C;
 173   6                                                      
C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 4   

 174   6                                                      //×ó1
 175   6                                                      temp16 = ad_chn_sample.w;
 176   6                                                      uart1_q[i].tdata[7] = HIGH(temp16);
 177   6                                                      uart1_q[i].tdata[8] = LOW(temp16);
 178   6                                                              
 179   6                                                      for (j = 1; j < 8; j++) { //×ó2~8
 180   7                                                              uart1_q[i].tdata[7 + (j << 1)] = 0x00;
 181   7                                                              uart1_q[i].tdata[8 + (j << 1)] = 0x00;
 182   7                                                      }
 183   6      
 184   6                                                      
 185   6                                                      for (j = 0; j < 8; j++) { //ÓÒ1~8
 186   7                                                              uart1_q[i].tdata[23 + (j << 1)] = 0x00;
 187   7                                                              uart1_q[i].tdata[24 + (j << 1)] = 0x00;
 188   7                                                      }
 189   6      
 190   6                                                      uart1_q[i].len = 40;
 191   6                                              } else {
 192   6                                                      //ÎŞ¿ÕÏĞbuffer, ¶ªÆú±¾ÃüÁî
 193   6                                                      //¼ì²é: ÈôÓĞ¶ÓÁĞÏîÕıÔÚ·¢ËÍ, µÈ´ıËüÍê³É
 194   6                                                      while (uart1_q_index != 0xFF);  //ÈôËÀËø,½«ÒıÆğ WDT ¸´Î»
 195   6                                              }
 196   5                                              break;
 197   5      
 198   5                                      case 0x15: //¶Á¾²Ì¬ÕÅÁ¦»ù×¼
 199   5                                              //ÔÚUART¶ÓÁĞÖĞÕÒ¿ÕÏĞBuffer
 200   5                                              i = uart1_get_buffer();
 201   5                                              if (i < UART_QUEUE_NUM) {
 202   6                                                      //ÕÒµ½ÁË¿ÕÏĞbuffer, Ğ´Èëdata
 203   6                                                      uart1_q[i].tdata[0] = FRAME_STX;
 204   6                                                      uart1_q[i].tdata[1] = msg1_buf[1];          //Ä¿µÄµØÖ·
 205   6                                                      uart1_q[i].tdata[2] = gl_comm_addr;         //Ô´µØÖ·
 206   6                                                      uart1_q[i].tdata[3] = 0x23;
 207   6                                                      uart1_q[i].tdata[4] = CMD_ZL_PRE;
 208   6                                                      uart1_q[i].tdata[5] = 0x21;
 209   6                                                      uart1_q[i].tdata[6] = 0x1D;
 210   6                                                      
 211   6                                                      //×ó1
 212   6                                                      temp16 = ad_chn_base.base;
 213   6                                                      uart1_q[i].tdata[7] = HIGH(temp16);
 214   6                                                      uart1_q[i].tdata[8] = LOW(temp16);
 215   6                                                              
 216   6                                                      for (j = 1; j < 8; j++) { //×ó2~8
 217   7                                                              uart1_q[i].tdata[7 + (j << 1)] = 0x00;
 218   7                                                              uart1_q[i].tdata[8 + (j << 1)] = 0x00;
 219   7                                                      }
 220   6      
 221   6                                                      for (j = 0; j < 8; j++) { //ÓÒ1~8
 222   7                                                              uart1_q[i].tdata[23 + (j << 1)] = 0x00;
 223   7                                                              uart1_q[i].tdata[24 + (j << 1)] = 0x00;
 224   7                                                      }
 225   6      
 226   6                                                      uart1_q[i].len = 40;
 227   6                                              } else {
 228   6                                                      //ÎŞ¿ÕÏĞbuffer, ¶ªÆú±¾ÃüÁî
 229   6                                                      //¼ì²é: ÈôÓĞ¶ÓÁĞÏîÕıÔÚ·¢ËÍ, µÈ´ıËüÍê³É
 230   6                                                      while (uart1_q_index != 0xFF);  //ÈôËÀËø,½«ÒıÆğ WDT ¸´Î»
 231   6                                              }
 232   5                                              break;
 233   5      
 234   5                                      case 0x40: //ÉèÖÃ¾²Ì¬ÕÅÁ¦Öµ·¶Î§
 235   5                                              //1. Ğ´Èëflash
C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 5   

 236   5                                              flash_enable();
 237   5                                              flash_erase(EEPROM_SECTOR3);
 238   5                                              flash_write(msg1_buf[6], EEPROM_SECTOR3 + 1);
 239   5                                              flash_write(msg1_buf[7], EEPROM_SECTOR3 + 2);
 240   5                                              flash_write(msg1_buf[8], EEPROM_SECTOR3 + 3);
 241   5                                              flash_write(msg1_buf[9], EEPROM_SECTOR3 + 4);
 242   5                                              flash_write(0x5a, EEPROM_SECTOR3);
 243   5                                              flash_disable();
 244   5      
 245   5                                              //2. ¸üĞÂ±äÁ¿
 246   5                                              ad_still_dn = ((Uint16)msg1_buf[6] << 8) + msg1_buf[7];  //ÏÂÏŞ
 247   5                                              ad_still_up = ((Uint16)msg1_buf[8] << 8) + msg1_buf[9];  //ÉÏÏŞ
 248   5      
 249   5                                              break;
 250   5                                              
 251   5                                      case 0x50: //ÉèÖÃ±¨¾¯·§Öµ
 252   5                                              //1. Ğ´Èëflash²¢¸üĞÂ±äÁ¿
 253   5                                              flash_enable();
 254   5                                              flash_erase(EEPROM_SECTOR4);
 255   5      
 256   5                                              ad_still_Dup = msg1_buf[7];
 257   5                                              flash_write(msg1_buf[7], EEPROM_SECTOR4 + 1);
 258   5      
 259   5                                              flash_write(0x5a, EEPROM_SECTOR4);
 260   5                                              flash_disable();
 261   5      
 262   5                                              //ÏÂÏŞ¹Ì¶¨È¡»ù×¼ÖµµÄ 1/3
 263   5                                              //2. ¸üĞÂ»»ËãºóµÄÕÅÁ¦±¨¾¯ÉÏÏŞ(²ÉÑùÖµ)
 264   5                                              if (system_status == SYS_CHECK) {
 265   6                                                      //ÒÑ¿ªÊ¼ÔËĞĞ¼ì²â
 266   6                                                      if ((1023 - ad_chn_base.base) > ad_still_Dup)
 267   6                                                              ad_chn_base.base_up = ad_chn_base.base + ad_still_Dup;
 268   6                                                      else
 269   6                                                              ad_chn_base.base_up = 1023;
 270   6                                              }
 271   5                                              break;
 272   5      
 273   5                                      case 0x60: //ÉèÖÃÉù¹â±¨¾¯Ê±¼ä
 274   5                                              //1. Ğ´Èëflash
 275   5                                              flash_enable();
 276   5                                              flash_erase(EEPROM_SECTOR5);
 277   5                                              flash_write(msg1_buf[6], EEPROM_SECTOR5 + 1);
 278   5                                              flash_write(0x5a, EEPROM_SECTOR5);
 279   5                                              flash_disable();
 280   5      
 281   5                                              //2. ¸üĞÂ±äÁ¿
 282   5                                              beep_during_temp = (Uint16)(((Uint32)msg1_buf[6] * 1000) / SCHEDULER_TICK);
 283   5                                              break;
 284   5                                              
 285   5                                      case 0xF1: //ÉèÖÃ´«¸ĞÆ÷²ÉÑùÆ«²î---->Ïû³ıµçÂ·ÉÏµÄÎó²î                  
 286   5                                              //1. Ğ´Èëflash²¢¸üĞÂ±äÁ¿
 287   5                                              flash_enable();
 288   5                                              flash_erase(EEPROM_SECTOR6);
 289   5      
 290   5                          sensor_sample_offset = ((Uint16)msg1_buf[6] << 8) + msg1_buf[7];
 291   5                                              flash_write(msg1_buf[6], EEPROM_SECTOR6 + 1);
 292   5                                              flash_write(msg1_buf[7], EEPROM_SECTOR6 + 2);
 293   5                                                      
 294   5                                              flash_write(0x5a, EEPROM_SECTOR6);
 295   5                                              flash_disable(); 
 296   5      
 297   5                                              break;
C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 6   

 298   5                                      }
 299   4                                      break;
 300   4                              }
 301   3                      }
 302   2      
 303   2                      //a.3 ÉèÖÃÓ¦´ğÑÓÊ±
 304   2                      Disable_interrupt();
 305   2                      gl_ack_tick = REPLY_DLY;
 306   2                      Enable_interrupt();
 307   2      
 308   2                      //a.4 ¸´Î»±êÖ¾
 309   2                      msg1_buf_valid = FALSE;
 310   2              }
 311   1      
 312   1              //3. UART1 ¶ÓÁĞ·¢ËÍ
 313   1              if ((uart1_q_index == 0xFF) && (recv1_state == FSA_INIT) && (gl_ack_tick == 0)) {
 314   2                      //UART1ÎŞ½øÈë·¢ËÍÁ÷³ÌµÄ¶ÓÁĞÏî, ÕÒÊÇ·ñÓĞµÈ´ı·¢ËÍµÄÏî
 315   2                      for (i = 0; i < UART_QUEUE_NUM; i++) {
 316   3                              if (uart1_q[i].flag == 1) {
 317   4                                      //ÓĞµÈ´ı·¢ËÍµÄÏî£¬°²ÅÅ´ËÏî·¢ËÍ
 318   4                                      uart1_q[i].flag = 2;
 319   4                                      uart1_q_index = i;
 320   4                                      memcpy(trans1_buf, uart1_q[i].tdata, uart1_q[i].len - 1);
 321   4                                      trans1_size = uart1_q[i].len;
 322   4                                      uart1_start_trans();
 323   4                                      break;
 324   4                              }
 325   3                      }
 326   2              }
 327   1      }
 328          
 329          /***************************************************************************
 330          * NAME: uart1_get_buffer
 331          *----------------------------------------------------------------------------
 332          * PARAMS:
 333          * return: Byte
 334          *         Èô·µ»ØÖµ >= UART_QUEUE_NUM, Ôò±íÊ¾Ã»ÓĞÉêÇëµ½¿ÕÏĞbuffer
 335          *----------------------------------------------------------------------------
 336          * PURPOSE: ÔÚ´®¿Ú¶ÓÁĞÖĞÑ°ÕÒ¿ÕÏĞ¶ÓÁĞÏî£¬ÈôÕÒµ½£¬·µ»Ø¶ÓÁĞÏîĞòºÅ(0 ~ (UART_QUEUE_NUM-1))
 337          *----------------------------------------------------------------------------
 338          * REQUIREMENTS:
 339          *****************************************************************************/
 340          Byte uart1_get_buffer(void)
 341          {
 342   1              Byte i, flag;
 343   1      
 344   1              for (i = 0; i < UART_QUEUE_NUM; i++) {
 345   2                      Disable_interrupt();
 346   2                      flag = uart1_q[i].flag;
 347   2                      Enable_interrupt();
 348   2                      if (flag == 0) { //ÒÑÕÒµ½¿ÕÏĞBuffer
 349   3                              uart1_q[i].flag = 1;
 350   3                              break;
 351   3                      }
 352   2              }
 353   1              return i;
 354   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2259    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.54   UART_TASK                                                             05/13/2016 14:54:23 PAGE 7   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
