C51 COMPILER V9.54   TIMER_DRV                                                             07/01/2016 17:14:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TIMER_DRV
OBJECT MODULE PLACED IN .\Objects\timer_drv.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE driver\timer\timer_drv.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Lis
                    -tings\timer_drv.lst) OBJECT(.\Objects\timer_drv.obj)

line level    source

   1          #include "driver/timer/timer_drv.h"
   2          #include "driver/adc/adc_drv.h"
   3          
   4          /* UART1 */
   5          extern idata  Byte        recv1_state;                 // receive state
   6          extern idata  Byte        recv1_timer;                 // receive time-out, 用于字节间超时判定
   7          
   8          /* for AD */
   9          extern data   sAD_Sample  ad_sample;                   // 保存当前采样值
  10          
  11          /* Doorkeep */   
  12          extern xdata  Byte        gl_dk_tick;                  //门磁检测计时tick  
  13          
  14          /* 系统计时 */
  15          extern xdata  Uint16      gl_delay_tick;               //通用延时用tick
  16          extern xdata  Byte        gl_ack_tick;                 //应答延时计时 tick
  17          
  18          
  19          /* variables for alarm output */ 
  20          extern bdata  bit         alarm1_flag;
  21          extern data   Uint16      alarm1_timer;                // 计时器，报警器1已报警时间,单位tick 
  22          extern data   Uint16      ad_alarm_tick;               //各通道报警计时tick
  23           
  24          /* 传感器采样偏差 */
  25          extern xdata  Uint16      sensor_sample_offset;        //传感器采样偏差：没有外力时，传感器采样值不为0，大
             -约400左右，需要矫正。瞬间张力 = 采样值 - 采样偏差
  26          
  27          void timer0_init(void)   // 5ms@22.1184MHz
  28          {    
  29   1          // 定时器0初始化
  30   1              AUXR &= 0x7F;            // 设置为12T模式
  31   1              TMOD &= 0xF0;            // 设置为工作模式1
  32   1              TMOD |= 0x01;
  33   1              TL0 = 0x00;                  // 设置定时初值
  34   1              TH0 = 0xDC;                  // 设置定时初值
  35   1              TF0 = 0;                     // 清除TF0标志
  36   1          ET0 = 1;             // 使能T0中断允许位
  37   1          IPH |= (1 << 1);
  38   1          PT0 = 0;             // 设置中断优先级为优先级2
  39   1              TR0 = 1;                     // 定时器0开始计时
  40   1              
  41   1              // 启动AD转换
  42   1              ADC_CONTR |= ADC_START;
  43   1      }
  44          
  45          void timer0_isr(void) interrupt TF0_VECTOR using 1
  46          {                      
  47   1          // 重装初值
  48   1              TL0 = 0x00;                  // 设置定时初值
  49   1              TH0 = 0xDC;                  // 设置定时初值
  50   1              TR0 = 1;                     // 定时器0开始计时
  51   1              
  52   1          // AD转换完成,将ADC_FLAG转换完成标志清零
  53   1          ADC_CONTR &= ~ADC_FLAG;
C51 COMPILER V9.54   TIMER_DRV                                                             07/01/2016 17:14:39 PAGE 2   

  54   1      
  55   1              // 读AD值
  56   1              if (ad_sample.valid == FALSE) {
  57   2                      // 原数据已经被处理, 可以写入新数据
  58   2                      ad_sample.val   = ADC_RES;             // 读高8位
  59   2                      ad_sample.val   = ad_sample.val << 2;
  60   2                      ad_sample.val   += (ADC_RESL & 0x03);  // 得到10bit采样值
  61   2                      ad_sample.valid = TRUE;
  62   2                      
  63   2                      //采样值减去采样偏差
  64   2      /*              if (ad_sample.val > sensor_sample_offset) {
  65   2                              ad_sample.val -= sensor_sample_offset;
  66   2                      } else {
  67   2                              ad_sample.val = 0;
  68   2                      }  */
  69   2                      
  70   2                      ADC_CONTR |= ADC_START;                   // 启动转换
  71   2              }
  72   1      
  73   1              // increment task tick counters
  74   1              gl_dk_tick++;                                 //门磁检测计时tick
  75   1              gl_delay_tick++;                              //通用延时用tick
  76   1              if (gl_ack_tick > 0) {
  77   2                      gl_ack_tick--;                            //应答延时计时
  78   2              }
  79   1      
  80   1              ad_alarm_tick++;
  81   1              
  82   1              if (alarm1_flag) {
  83   2                      alarm1_timer++;
  84   2              }
  85   1       
  86   1              // UART1字节之间接收超时
  87   1              if (recv1_state != FSA_INIT) {
  88   2                      //非初始状态，需要检测是否超时
  89   2                      if (recv1_timer > 0) {
  90   3                              recv1_timer--;
  91   3                      }
  92   2                      
  93   2                      if (recv1_timer == 0){
  94   3                              recv1_state = FSA_INIT;   //接收超时, 恢复至初始状态
  95   3                      }
  96   2              }
  97   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    183    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
